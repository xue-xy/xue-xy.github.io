<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xue-xy.github.io</id>
    <title>Xue Xiaoyong</title>
    <updated>2021-04-14T08:38:29.304Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xue-xy.github.io"/>
    <link rel="self" href="https://xue-xy.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://xue-xy.github.io/images/avatar.png</logo>
    <icon>https://xue-xy.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Xue Xiaoyong</rights>
    <entry>
        <title type="html"><![CDATA[NuXmv学习笔记]]></title>
        <id>https://xue-xy.github.io/post/Nuxmv学习笔记/</id>
        <link href="https://xue-xy.github.io/post/Nuxmv学习笔记/">
        </link>
        <updated>2021-04-01T01:38:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="nuxmv学习笔记">NuXmv学习笔记</h1>
<p>Tip: Fram condition. Variables that are not constrained in the transition will change their value non-deterministically.</p>
<h2 id="安装">安装</h2>
<p>去<a href="https://nuxmv.fbk.eu/pmwiki.php?n=Download.Download">官网</a>上选择适合自己系统的版本下载即可，这里使用的是mac版本。在文件夹下的<code>/bin/</code>文件夹中的<code>nuXmv</code>便是执行文件。</p>
<p>想要进行交互式操作可以在终端定位到该文件夹后执行<code>./nuXmv -int</code>即可。也可以吧nuxmv变成全局的命令，可在<code>zshrc</code>文件中添加</p>
<pre><code class="language-bash">alias nuxmv=$FilePath/bin/nuXmv
</code></pre>
<p>其中<code>FilePath</code>是下载的文件夹的路径。</p>
<blockquote>
<p>使用Apple Silicon的注意事项</p>
<p>NuXmv需要x86版本的gmp，这个可以使用x86版本的homebrew进行安装。x86版本的homebrew配置方法可以见<a href="https://sspai.com/post/63935">这篇文章</a>。</p>
</blockquote>
<h2 id="有限状态系统">有限状态系统</h2>
<p>网上的<a href="https://blog.csdn.net/shu15121856/category_10584646.html">几篇教程</a>.  这个教程中主要讨论了在有限状态情况下的系统建模与验证，与NuSmv的情况有些相似。</p>
<ul>
<li><code>read_model -i filename</code>读取模型文件。</li>
<li><code>show_property</code>展示模型文件中的性质。</li>
<li><code>show_traces</code>查看某个迹。</li>
</ul>
<h2 id="无限状态系统">无限状态系统</h2>
<p>有些命令在无限状态的模型中无法使用，这里记录一些在无限状态情况下使用的命令。</p>
<ul>
<li><code>go_mast</code> 初始化模型，和原来的go有些相似。</li>
<li><code>msat_pick_state</code>从初始状态中挑选一个作为当前的状态，并可以以此展开一条新的路径。</li>
<li><code>msat_simulate</code> 进行模拟执行。-k length表示模拟的步数。</li>
<li><code>msat_check_invar_bmc</code>使用BMC进行不变式检查，直接用有些问题。</li>
<li><code>check_invar_ic3</code>使用msatic3进行不变式检验，感觉很好用。-n指定要检查的性质，-k指定步数。</li>
<li><code>msat_check_ltlspec_bmc</code>使用BMC进行LTL性质检查。</li>
<li><code>check_ltlspec_ic3</code>使用ic3进行LTL性质检查。和上面的的都可用，但是在无限状态下LTL性质难以被检查出来。</li>
</ul>
<h2 id="注意事项">注意事项</h2>
<ul>
<li>TRANS中的条件最好是互相不重复，否则可能会出现混淆导致无法执行。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Paper Reading - April, 2021]]></title>
        <id>https://xue-xy.github.io/post/paper-reading/</id>
        <link href="https://xue-xy.github.io/post/paper-reading/">
        </link>
        <updated>2021-04-01T01:38:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="token-modification-adversarial-attacks-for-natural-language-processing-a-survey"><a href="https://arxiv.org/abs/2103.00676">Token-Modification Adversarial Attacks for Natural Language Processing: A Survey</a></h2>
<p>A Survey about adversarial attack using token modification on NLP tasks.</p>
<ul>
<li>Token modification methods</li>
</ul>
<blockquote>
<ol>
<li>replace one wiht another</li>
<li>insert a token</li>
<li>delete a toekn</li>
<li>change token ordering</li>
</ol>
</blockquote>
<ul>
<li>Token replacement ideas.</li>
</ul>
<blockquote>
<ol>
<li>Replace a word with any word. Often used in character level. Attack in embedding space attacks for images.</li>
<li>Replace some character with similar-looking characters. Character levle. The mapping is constructed by human or by treating characters as images.</li>
<li>Replace tokens with hunman errors like misspelling on Wiki or adjacent characters on keyboard.</li>
<li>Close point in embedding space are similar words. Use counter-fitted embeddings to select synonyms.</li>
<li>Replace target token with a mask and use a language model to predict it.</li>
</ol>
</blockquote>
<p>Loss guided $ \partial{l} / \partial{x} $ or $\partial{f(x)} / \partial{x} $. The latter is for specific class attack.</p>
<h2 id="repairing-deep-neural-networks-fix-patterns-and-challenges"><a href="https://dl.acm.org/doi/10.1145/3377811.3380378">Repairing Deep Neural Networks: Fix Patterns and Challenges</a></h2>
<p>An empirical study about bug fix patterns in neural network developing. Bug fix pattern includes loss function, add layer, connection, activation, iterations, optimizer, accuracy metric, etc. The bugs can be roughly classified as network-related and non-network-related.</p>
<p>Non-network-related bugs include version bugs and data dimension bugs and so on. They casue code crash. Network-related bugs are about network structue or loss function. They usually don't make code break down, but they lead to bad performance. Changing these parts of the network may increse prediction accuracy.</p>
<h2 id="adversarial-sample-detection-for-deep-neural-network-through-model-mutation-testing"><a href="https://ieeexplore.ieee.org/document/8812047">Adversarial Sample Detection for Deep Neural Network through Model Mutation Testing</a></h2>
<p>Their observation is adversarial samples are much more sensitive than normal samples if we impose random mutations on the DNN.</p>
<p>Reading.</p>
<h2 id="neurodiff-scalable-differential-verification-of-neural-networks-using-fine-grained-approximation"><a href="https://dl.acm.org/doi/10.1145/3324884.3416560">NeuroDiff: scalable differential verification of neural networks using fine-grained approximation</a></h2>
<p>Reading.</p>
<h2 id="multiple-boundary-clustering-and-prioritization-to-promote-neural-network-retraining"><a href="https://dl.acm.org/doi/10.1145/3324884.3416621">Multiple-boundary clustering and prioritization to promote neural network retraining</a></h2>
<p>Reading.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mediator源码结构]]></title>
        <id>https://xue-xy.github.io/post/mediator源码结构/</id>
        <link href="https://xue-xy.github.io/post/mediator源码结构/">
        </link>
        <updated>2020-12-07T06:34:41.000Z</updated>
        <content type="html"><![CDATA[<p>最新的代码发布在<a href="https://github.com/xue-xy/Mediator_origin">https://github.com/xue-xy/Mediator_origin</a>。</p>
<h2 id="语法文件">语法文件</h2>
<p>src-antlr是mediator的语法文件，语法使用ANTLR进行处理，由其生成的文件在org.fmgroup.mediator.languange.generated中。</p>
<h2 id="src中的文件">src中的文件</h2>
<p>common</p>
<p>core. 命令行启动入口。</p>
<p>environment</p>
<p>plugin</p>
<p>plugins. 一些附加的插件，比如向其它语言的转换器，scheduler等。</p>
<h3 id="language">language</h3>
<p>这一部分内容较多，所以要单独进行记录。</p>
<p>entity. 自动机和系统的实现。在转移的部分，Transition是接口，TransitionSingle和TransitionGroup是它的两个实现。自动机中的Transition是一个Transition的ArrayList。</p>
<p>function</p>
<p>generated. 存放由语法文件经由ANTLR自动生成的文件。Mediator中只用了Listener模式进行生成。但在实际分析中并没有使用。</p>
<p>property</p>
<p>scope. 其中的VariableDeclarationCollection是变量声明的集合。VaribleDeclaration是单个的变量声明。</p>
<p>statement. 保存了各种类型的Statement。接口Statement是parser的入口。接口Statements没有进行实现，一条转移中有多个命令的处理是通过分别处理每条语句的方式进行的。</p>
<p>term. 各种类型项的具体实现。</p>
<p>type. 保存了各个类型的实现及处理。接口Type中的静态方法parse将type进行分类。</p>
<p>Program. 程序的入口，其中的parseFile方法是parse的入口，它读取文件然后进行parse，最后得到prog的context。</p>
<h2 id="其它文件">其它文件</h2>
<p>resource中放置的是一些测试例子的文件。</p>
<p>scripts是启动时的一些脚本文件。</p>
<h2 id="额外注释">额外注释</h2>
<ol>
<li>各个内容类中的fromContext方法是从context构建成自己的数据结构。antlr的contex是一个序列，记录着从当前节点到根节点的路径。</li>
<li>meta是记录一系列的term，用法尚待考察。</li>
<li>parse得到的结构是一个树状的结构。parse的过程是从根到叶这个方向进行的，每个结构都记录自己的父结构。</li>
</ol>
<h2 id="待解决的问题">待解决的问题</h2>
<ol>
<li>Double类型的值不能使用。原来实现了DoubleValue，但是没有在Term中引过去（已经解决）。</li>
<li>refactor方法还没有处理类型之间的映射，有些类别的refactor方法也没有实现。在schedule和复制的时候会用到refactor方法（部分类型的已经解决）。</li>
<li>类型检查没有做。变量和其值的类型可能不对应。作条件的有可能不是bool类型的项。</li>
<li>schedule得到的自动机可读性差，其中转移的条件过长，没有进行处理。</li>
<li>端口只有一个字母A的时候语法错误，目前原因未知。可能是由于ANTLR语法定义优先级的问题。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ANTLR学习记录]]></title>
        <id>https://xue-xy.github.io/post/antlr学习笔记/</id>
        <link href="https://xue-xy.github.io/post/antlr学习笔记/">
        </link>
        <updated>2020-12-04T13:49:29.000Z</updated>
        <content type="html"><![CDATA[<p>看到知乎用户陈乐群的两篇ANTLR笔记<a href="https://abcdabcd987.com/notes-on-antlr4/">（一）</a><a href="https://abcdabcd987.com/using-antlr4/">（二）</a></p>
<p>在CSDN上看到关于ANTLR在Intellij IDEA上的使用的文章<a href="https://blog.csdn.net/qq_37771475/article/details/106387201">（一）</a><a href="https://blog.csdn.net/qq_37771475/article/details/106426327">（二）</a><a href="https://blog.csdn.net/qq_37771475/article/details/106528661">（三）</a><a href="https://blog.csdn.net/qq_37771475/article/details/106546742">（四）</a>。对进行了标注的语法规则使用visitor进行访问和用递归的方式进行处理的思路是一样的。</p>
<h2 id="antlr进行将文件转为语法树的流程">ANTLR进行将文件转为语法树的流程</h2>
<p>过程为：文件流 -&gt; 字符流 -&gt; 词法解析器 -&gt; token流 -&gt; 语法解析器 -&gt; 从语法入口进入得到语法树。</p>
<pre><code class="language-java">import java.io.*;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;

InputStream is = new FileInputStream(file);
\\将输入文件转为输入数据流
DSLLexer lexer = new DSLLexer(CharStreams.fromStream(is));
\\括号里为将输入流转化为字符流，然后送入词法分析器
CommonTokenStream ts = new CommonTokenStream(lexer);
\\词法分析后得到token流
DSLParser parser = new DSLParser(ts);
\\生成语法分析器
ParseTree tree = parser.prog();
\\从入口开始进行语法分析 
</code></pre>
<p>也可以通过下面方法从某个规则进入</p>
<pre><code class="language-java">DSLParser.MainContext prog = parser.prog();
</code></pre>
<p>每条语法规则都有对应的context，可以根据context的不同去对具体的单元进行不同的处理。Mediator中是这样做的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用github+Gridea建立个人博客]]></title>
        <id>https://xue-xy.github.io/post/使用github+gridea搭建博客/</id>
        <link href="https://xue-xy.github.io/post/使用github+gridea搭建博客/">
        </link>
        <updated>2020-12-04T13:49:29.000Z</updated>
        <content type="html"><![CDATA[<p>待续。</p>
]]></content>
    </entry>
</feed>